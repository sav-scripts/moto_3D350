<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>threejs learn</title>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden;}
        canvas { width: 100%; height: 100% }
    </style>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script type="text/javascript" src="js/lib/stats.min.js"></script>

    <script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec4 ca;

			varying vec4 vColor;

			void main() {

				vColor = ca;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( 150.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

    <script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec4 vColor;

			void main() {

				vec4 outColor = texture2D( texture, gl_PointCoord );

				//if ( outColor.a < 0.5 ) discard;

				gl_FragColor = outColor * vec4( color * vColor.xyz, 1.0 );

				//gl_FragColor = outColor;


				float depth = gl_FragCoord.z / gl_FragCoord.w;
				const vec3 fogColor = vec3( 0.0 , .0, .0 );

				float fogFactor = smoothstep( 400.0, 2200.0, depth );

				//float fogFactor = 1.0;
				//gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );

			}

		</script>

    <script>

        "use strict";

        var renderer, scene, camera, stats;

        var object, uniforms, attributes;

        var mouseX = 0, mouseY = 0, windowHalfX, windowHalfY;

        var CAMERA_Z = 2000;

        var vc1;

        var WIDTH = window.innerWidth;
        var HEIGHT = window.innerHeight;

        var rawWorld = {};

        function init()
        {
            getWorldMapData(buildScene);
        }

        function getGeometry()
        {
            var geometry = new THREE.Geometry();

            var imageWidth = rawWorld.image.width,
                imageHeight = rawWorld.image.height;

            var gap = 4;
            var left = -imageWidth*.5*gap;
            var top = -imageHeight*.5*gap;

            var imageData = rawWorld.ctx.getImageData(0,0,imageWidth,imageHeight);

            console.log(imageData.length);

            for(var h=0;h<imageHeight;h+=1)
            {
                for(var w=0;w<imageWidth;w+=1)
                {
                    //var color = imageData.data[(h*imageWidth+w)*4];

                    var index = (h*imageWidth+w)*4;

                    var color = new THREE.Color("rgb("+imageData.data[index]+","+imageData.data[index+1]+","+imageData.data[index+2]+")");

                    //if(color < 255)
                    if(color.getHSL().l < .99)
                    {
                        var vertex = new THREE.Vector3();
                        vertex.x = left + w*gap;
                        vertex.y = top + h*gap;
                        vertex.z = 0;

                        geometry.vertices.push( vertex );
                    }
                }
            }


            colorGeometry(geometry);


            return geometry;
        }

        function getGeometry_1()
        {
            var geometry = new THREE.BoxGeometry(100,100,100, 5, 5, 5);
            colorGeometry(geometry);
            vc1 = geometry.vertices.length;
        }

        function colorGeometry(geometry)
        {
            var vertices = geometry.vertices;

            var values_size = attributes.size.value;
            var values_color = attributes.ca.value;

            for ( var v = 0; v < vertices.length; v ++ ) {

                values_size[ v ] = 10;
                values_color[ v ] = new THREE.Color( 0xffffff );

                //values_color[ v ].setHSL( 0.5 + 0.2 * ( v / vc1 ), 1, 0.5 );
                values_color[v].setHSL(48/360, 1,.5);
            }

            return geometry;
        }

        function buildScene()
        {

            setupStats();

            attributes = {

                size: {	type: 'f', value: [] },
                ca:   {	type: 'c', value: [] }

            };

            uniforms = {

                amplitude: { type: "f", value: 1.0 },
                color:     { type: "c", value: new THREE.Color( 0xffffff ) },
                texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "textures/sprites/dot_2.png" ) }

            };

            uniforms.texture.value.wrapS = uniforms.texture.value.wrapT = THREE.RepeatWrapping;

            var shaderMaterial = new THREE.ShaderMaterial( {

                uniforms:       uniforms,
                attributes:     attributes,
                vertexShader:   document.getElementById( 'vertexshader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

                blending:       THREE.AdditiveBlending,
                depthTest:      false,
                transparent:    true

            });





            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 40, WIDTH / HEIGHT, 1, 4000 );
            camera.position.z = CAMERA_Z;

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( WIDTH, HEIGHT );
            document.body.appendChild( renderer.domElement );



           var geometry = getGeometry();

            object = new THREE.PointCloud(geometry, shaderMaterial);
            scene.add(object);

            console.log("vertices count = " + geometry.vertices.length);




            //camera.position.z = 5;

            function render() {
                requestAnimationFrame( render );

                var time = Date.now() * 0.01;




                for( var i = 0; i < attributes.size.value.length; i ++ ) {

//                        attributes.size.value[ i ] = Math.max(0, 26 + 32 * Math.sin( 0.1 * i + 0.6 * time ));
                    attributes.size.value[ i ] = 100;


                }

                attributes.size.needsUpdate = true;


//                object.rotation.y = object.rotation.z = 0.02 * time;

                object.rotation.x = Math.PI;


//                console.log(mouseX);

                camera.position.x += ( mouseX - camera.position.x ) * 0.05;
//                camera.position.y += ( - mouseY - camera.position.y ) * 0.05;

                camera.position.z += (mouseY*3-(camera.position.z-CAMERA_Z))*.05;
//                camera.position.x = mouseX;
                //camera.position.y = mouseY*.05;

                camera.lookAt( scene.position );

                renderer.render( scene, camera );


                stats.update();
            }
            onWindowResize();
            render();


            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            window.addEventListener( 'resize', onWindowResize, false );

        }


        function onDocumentMouseMove( event ) {

            mouseX = ( event.clientX - windowHalfX );
            mouseY = ( event.clientY - windowHalfY );

        }


        function onWindowResize() {

            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        /** handle world map source **/
        function getWorldMapData(cb)
        {
            var canvas = rawWorld.canvas = document.createElement("canvas");
//            canvas.width = 200;
//            canvas.height = 200;

            canvas.style.position = 'absolute';
            canvas.style.zIndex = 1000;

            var ctx = rawWorld.ctx = canvas.getContext("2d");

            //canvas.loadim


            var image = rawWorld.image = new Image();

            image.onload = function()
            {
                console.log("loaded");

                canvas.width = image.width;
                canvas.height = image.height;

                $(canvas).width(image.width).height(image.height).css("bottom", 0);


                ctx.drawImage(image, 0, 0);

                if(cb) cb.apply();
            };

            image.src = "images/big_blank.png";


//            document.body.appendChild( canvas );
        }

        /** misc **/
        function setupStats()
        {

            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.top = '0px';
            stats.domElement.style.zIndex = 999;
            document.body.appendChild( stats.domElement );
        }

    </script>
</head>
<body onload="init();">

</body>
</html>